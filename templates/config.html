
<!doctype html>
<html lang="en">
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width,initial-scale=1">
		<title>Team Configuration</title>
		<link rel="stylesheet" href="{{ url_for('static', filename='styles.css') }}">
	</head>
	<body>
		<nav class="navbar">
			<div class="container nav-inner">
				<a class="brand" href="{{ url_for('index') }}">ScoringEngine</a>
				<div class="nav-cycle" id="navCycle">Cycle #{{ grading_cycle_count }}</div>
						<div class="nav-links">
							<a href="{{ url_for('index') }}">Status</a>
							<a href="{{ url_for('leaderboard') }}">Leaderboard</a>
							<a class="active" href="{{ url_for('config') }}">Team Config</a>
							{% if session.get('logged_in') %}
								<a href="{{ url_for('logout') }}">Logout</a>
							{% else %}
								<a href="{{ url_for('login') }}">Login</a>
							{% endif %}
						</div>
			</div>
		</nav>

		<main class="container">
			<div class="page-header">
				<h1>Team Configuration</h1>
				<div class="btn-group">
					<a class="btn btn-secondary" href="{{ url_for('index') }}">Status Matrix</a>
					<a class="btn btn-outline" href="{{ url_for('leaderboard') }}">View Leaderboard</a>
				</div>
			</div>

			<p class="subtle mb-3">Update the SSH credentials and ports for your team's systems. Changes are disabled while grading is running.</p>

			<div id="gradingBanner" class="alert warn mb-3" style="display:none;">
				Grading is currently in progress. Editing is temporarily disabled.
			</div>

			<form id="configForm">
				<div class="grid two">
					<div class="card">
						<div class="card-header" id="teamHeader">Your Team</div>
						<div class="card-body">
							<h3 class="mb-2">Ubuntu 1</h3>
							<fieldset class="mb-2">
								<legend>SSH</legend>
								<label for="ubuntu1_ssh_username">Username</label>
								<input id="ubuntu1_ssh_username" name="ubuntu1.ssh.username" type="text" required>
								<label for="ubuntu1_ssh_password">Password</label>
								<input id="ubuntu1_ssh_password" name="ubuntu1.ssh.password" type="password" required>
								<label for="ubuntu1_ssh_port">Port</label>
								<input id="ubuntu1_ssh_port" name="ubuntu1.ssh.port" type="number" min="1" max="65535" required>
							</fieldset>
							<fieldset>
								<legend>Web</legend>
								<label for="ubuntu1_web_port">Port</label>
								<input id="ubuntu1_web_port" name="ubuntu1.web.port" type="number" min="1" max="65535" required>
							</fieldset>
						</div>
					</div>

					<div class="card">
						<div class="card-header">&nbsp;</div>
						<div class="card-body">
							<h3 class="mb-2">Ubuntu 2</h3>
							<fieldset class="mb-2">
								<legend>SSH</legend>
								<label for="ubuntu2_ssh_username">Username</label>
								<input id="ubuntu2_ssh_username" name="ubuntu2.ssh.username" type="text" required>
								<label for="ubuntu2_ssh_password">Password</label>
								<input id="ubuntu2_ssh_password" name="ubuntu2.ssh.password" type="password" required>
								<label for="ubuntu2_ssh_port">Port</label>
								<input id="ubuntu2_ssh_port" name="ubuntu2.ssh.port" type="number" min="1" max="65535" required>
							</fieldset>
							<fieldset>
								<legend>Web</legend>
								<label for="ubuntu2_web_port">Port</label>
								<input id="ubuntu2_web_port" name="ubuntu2.web.port" type="number" min="1" max="65535" required>
							</fieldset>
						</div>
					</div>
				</div>
				<div class="actions">
					<button type="submit" id="saveBtn" class="btn btn-primary">Save Changes</button>
					<span class="status" id="saveStatus"></span>
				</div>
			</form>

			<div class="mt-3">
				<h2 class="mb-2">Current Check Status</h2>
				<p class="subtle">Cells show the last result for each check. Hover to see the full error message.</p>
				<div class="card mt-2">
					<div class="card-body table-responsive">
						<div id="statusTableContainer"></div>
					</div>
				</div>
			</div>
		</main>

		<script src="{{ url_for('static', filename='error_banner.js') }}"></script>
		<script>
		  async function refreshCycle() {
			try {
			  const r = await fetch('/api/grading-status');
			  if (!r.ok) return;
			  const data = await r.json();
			  const el = document.getElementById('navCycle');
			  if (el && typeof data.cycle === 'number') {
				el.textContent = `Cycle #${data.cycle}`;
			  }
			} catch {}
		  }
		  refreshCycle();
		  setInterval(refreshCycle, 5000);
		</script>
    <script>
      try {
        const socket = io();
        socket.on('gradingCycle', (payload) => {
          const el = document.getElementById('navCycle');
          if (el && payload && typeof payload.cycle === 'number') {
            el.textContent = `Cycle #${payload.cycle}`;
          }
        });
      } catch {}
    </script>
		<script>
			const form = document.getElementById('configForm');
			const saveBtn = document.getElementById('saveBtn');
			const saveStatus = document.getElementById('saveStatus');
			const gradingBanner = document.getElementById('gradingBanner');
			const teamHeader = document.getElementById('teamHeader');

			let currentTeam = null;

			async function fetchConfigs() {
				const res = await fetch('/api/team-configs');
				if (!res.ok) throw new Error('Failed to load team configs');
				return res.json();
			}

			async function fetchGradingStatus() {
				try {
					const res = await fetch('/api/grading-status');
					if (!res.ok) return { isGrading: false };
					return res.json();
				} catch { return { isGrading: false }; }
			}

			function setFormDisabled(disabled) {
				form.querySelectorAll('input, button').forEach(el => {
					el.disabled = disabled;
				});
				gradingBanner.style.display = disabled ? 'block' : 'none';
				form.classList.toggle('disabled', disabled);
			}

			function applyConfigs(cfg) {
				// cfg should have one key: team1 or team2
				const teamKey = Object.keys(cfg)[0];
				if (!teamKey) return;
				currentTeam = teamKey;
				teamHeader.textContent = teamKey === 'team1' ? 'Team 1' : 'Team 2';
				
				const teamData = cfg[teamKey] || { ubuntu1: {ssh: {}, web: {}}, ubuntu2: {ssh: {}, web: {}} };
				const u1 = teamData.ubuntu1 || { ssh: {}, web: {} };
				const u2 = teamData.ubuntu2 || { ssh: {}, web: {} };
				
				document.getElementById('ubuntu1_ssh_username').value = u1.ssh.username || '';
				document.getElementById('ubuntu1_ssh_password').value = u1.ssh.password || '';
				document.getElementById('ubuntu1_ssh_port').value = u1.ssh.port ?? 22;
				document.getElementById('ubuntu1_web_port').value = u1.web.port ?? 80;
				
				document.getElementById('ubuntu2_ssh_username').value = u2.ssh.username || '';
				document.getElementById('ubuntu2_ssh_password').value = u2.ssh.password || '';
				document.getElementById('ubuntu2_ssh_port').value = u2.ssh.port ?? 22;
				document.getElementById('ubuntu2_web_port').value = u2.web.port ?? 80;
			}

			function readForm() {
				if (!currentTeam) return {};
				return {
					[currentTeam]: {
						ubuntu1: {
							ssh: {
								username: document.getElementById('ubuntu1_ssh_username').value,
								password: document.getElementById('ubuntu1_ssh_password').value,
								port: parseInt(document.getElementById('ubuntu1_ssh_port').value, 10)
							},
							web: { port: parseInt(document.getElementById('ubuntu1_web_port').value, 10) }
						},
						ubuntu2: {
							ssh: {
								username: document.getElementById('ubuntu2_ssh_username').value,
								password: document.getElementById('ubuntu2_ssh_password').value,
								port: parseInt(document.getElementById('ubuntu2_ssh_port').value, 10)
							},
							web: { port: parseInt(document.getElementById('ubuntu2_web_port').value, 10) }
						}
					}
				};
			}

			async function init() {
				// Initial load
				const [cfg, status] = await Promise.all([fetchConfigs(), fetchGradingStatus()]);
				applyConfigs(cfg);
				setFormDisabled(Boolean(status.isGrading));
			}

			form.addEventListener('submit', async (e) => {
				e.preventDefault();
				saveStatus.textContent = '';
				saveStatus.className = 'status';
				saveBtn.disabled = true;
				try {
					const payload = readForm();
					const res = await fetch('/api/team-configs', {
						method: 'POST',
						headers: { 'Content-Type': 'application/json' },
						body: JSON.stringify(payload)
					});
					if (res.status === 409) {
						const body = await res.json();
						saveStatus.textContent = body.error || 'Grading in progress; try again later.';
						saveStatus.classList.add('error');
					} else if (!res.ok) {
						const body = await res.json().catch(() => ({}));
						saveStatus.textContent = body.error || 'Failed to save changes.';
						saveStatus.classList.add('error');
					} else {
						saveStatus.textContent = 'Saved!';
						saveStatus.classList.add('success');
					}
				} catch (err) {
					saveStatus.textContent = 'Error saving changes.';
					saveStatus.classList.add('error');
				} finally {
					saveBtn.disabled = false;
					// Refresh grading status just in case
					const status = await fetchGradingStatus();
					setFormDisabled(Boolean(status.isGrading));
				}
			});

			// Poll grading status to disable form while running
			setInterval(async () => {
				const status = await fetchGradingStatus();
				setFormDisabled(Boolean(status.isGrading));
			}, 5000);

			// Build and update a status table for this team
			function buildStatusTable(teamKey, scores) {
				const container = document.getElementById('statusTableContainer');
				container.innerHTML = '';
				const table = document.createElement('table');
				const thead = document.createElement('thead');
				const trh = document.createElement('tr');
				['System', 'Ping', 'SSH', 'Web'].forEach(h => { const th = document.createElement('th'); th.textContent = h; trh.appendChild(th); });
				thead.appendChild(trh);
				table.appendChild(thead);
				const tbody = document.createElement('tbody');
				['ubuntu1', 'ubuntu2'].forEach(u => {
					const tr = document.createElement('tr');
					const sysTh = document.createElement('th'); sysTh.textContent = u.toUpperCase(); tr.appendChild(sysTh);
					['ping', 'ssh', 'web'].forEach(svc => {
						const td = document.createElement('td');
						const key = `${u}${svc}`; // e.g., ubuntu1ping
						const svcObj = (scores[teamKey] || {})[key];
						const errStr = String(svcObj ? svcObj.error : 'Not tested');
						if (errStr === 'Success') {
							td.className = 'ok';
							td.textContent = 'Success';
						} else if (errStr === 'Not tested') {
							td.className = 'unknown';
							td.textContent = 'Not tested';
						} else {
							td.className = 'fail';
							td.textContent = 'Fail';
							const detail = document.createElement('span');
							detail.className = 'error-detail';
							const snippet = errStr.slice(0, 120);
							detail.textContent = snippet + (errStr.length > 120 ? '…' : '');
							td.appendChild(detail);
							td.title = errStr;
						}
						tr.appendChild(td);
					});
					tbody.appendChild(tr);
				});
				table.appendChild(tbody);
				container.appendChild(table);
			}

			async function fetchTeamScores() {
				try {
					const r = await fetch('/api/team-scores');
					if (!r.ok) {
						if (window.AppNotice) AppNotice.warn('Could not load team scores.');
						return {};
					}
					return r.json();
				} catch (e) {
					console.warn('fetchTeamScores failed', e);
					if (window.AppNotice) AppNotice.warn('Network error while loading team scores.');
					return {};
				}
			}

			async function initStatus() {
				try {
					const teamKey = currentTeam;
					if (!teamKey) return;
					const data = await fetchTeamScores();
					buildStatusTable(teamKey, data);
				} catch {}
			}

			// Kick off UI
			init().then(initStatus).catch(err => {
				saveStatus.textContent = 'Failed to load configs. Please refresh.';
				saveStatus.classList.add('error');
				if (window.AppNotice) AppNotice.error('Failed to load configuration.');
			});

			// Live updates via Socket.IO
			(function(){
				const s = document.createElement('script'); s.src = 'https://cdn.socket.io/4.7.2/socket.io.min.js'; s.onload = () => {
					const socket = io();
					socket.on('scores', (scores) => {
						if (!currentTeam) return;
						buildStatusTable(currentTeam, scores);
					});
					socket.on('disconnect', () => {
						if (window.AppNotice) AppNotice.warn('Disconnected from live updates. Changes are still saved.');
					});
				}; document.body.appendChild(s);
			})();
		</script>
	</body>
 </html>
